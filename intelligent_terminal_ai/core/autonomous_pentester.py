"""
Autonomous Penetration Testing Module

This module enables the AI to automatically explore and test websites
for security vulnerabilities, similar to giving instructions to an AI assistant.
"""

import asyncio
import json
import re
from typing import Dict, Any, List, Optional
from urllib.parse import urljoin, urlparse
import requests
from datetime import datetime

from ..models.command_result import CommandResult, BrowserResult, AnalysisResult
from ..utils.logger import setup_logger


class AutonomousPenTester:
    """
    AI-driven autonomous penetration testing engine
    """
    
    def __init__(self, ai_analyzer, browser_automator, terminal_executor):
        self.ai_analyzer = ai_analyzer
        self.browser_automator = browser_automator
        self.terminal_executor = terminal_executor
        self.logger = setup_logger(__name__)
        
        # Test knowledge base
        self.pentest_commands = [
            "Basic reconnaissance and information gathering",
            "Directory enumeration and hidden file discovery", 
            "SQL injection testing on forms and parameters",
            "Cross-site scripting (XSS) vulnerability testing",
            "Authentication bypass attempts",
            "Session management testing",
            "File upload vulnerability testing",
            "Command injection testing",
            "Security header analysis",
            "SSL/TLS configuration testing"
        ]
        
        # Common payloads for testing
        self.test_payloads = {
            "sql_injection": [
                "' OR '1'='1",
                "admin'--",
                "' UNION SELECT NULL--",
                "1; DROP TABLE users--",
                "' OR 1=1#"
            ],
            "xss": [
                "<script>alert('XSS')</script>",
                "javascript:alert('XSS')",
                "<img src=x onerror=alert('XSS')>",
                "'><script>alert('XSS')</script>",
                "<svg onload=alert('XSS')>"
            ],
            "command_injection": [
                "; ls -la",
                "| whoami",
                "&& cat /etc/passwd",
                "; ping -c 4 127.0.0.1",
                "| dir"
            ],
            "directory_traversal": [
                "../../../etc/passwd",
                "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                "....//....//....//etc/passwd",
                "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
            ]
        }
    
    async def autonomous_pentest_visual(self, target_url: str, depth: int = 3) -> Dict[str, Any]:
        """
        Perform autonomous penetration testing with real-time visual browser feedback
        """
        
        self.logger.info(f"üéØ Starting visual autonomous pentest of {target_url}")
        print(f"\nüåê REAL-TIME VISUAL PENETRATION TESTING")
        print(f"üéØ Target: {target_url}")
        print(f"üìä Watch the Chrome browser for real-time testing...")
        
        # Initialize report
        pentest_report = {
            "target": target_url,
            "timestamp": datetime.now().isoformat(),
            "phases": [],
            "risk_score": 0
        }
        
        try:
            # Make sure browser is started and visible
            await self.browser_automator.start_browser()
            
            # Phase 1: Visual Reconnaissance
            print(f"\nüîç Phase 1: Visual Reconnaissance & Discovery")
            phase1_results = await self._visual_reconnaissance(target_url)
            pentest_report["phases"].append(phase1_results)
            
            # Phase 2: Interactive Vulnerability Testing
            print(f"\nüîé Phase 2: Interactive Vulnerability Testing")
            phase2_results = await self._visual_vulnerability_testing(target_url)
            pentest_report["phases"].append(phase2_results)
            
            # Phase 3: AI-Guided Visual Exploitation
            print(f"\nüéØ Phase 3: AI-Guided Visual Exploitation")
            phase3_results = await self._visual_exploitation(target_url, pentest_report)
            pentest_report["phases"].append(phase3_results)
            
            # Phase 4: Final Analysis
            phase4_results = await self._phase_ai_analysis(pentest_report)
            pentest_report.update(phase4_results)
            
            self.logger.info("üéâ Visual autonomous pentest completed")
            print(f"\nüéâ Visual penetration testing completed!")
            print(f"üñ•Ô∏è  Check the browser window for final results")
            
            return pentest_report
            
        except Exception as e:
            self.logger.error(f"Visual pentest failed: {e}")
            pentest_report["error"] = str(e)
            return pentest_report

    async def _visual_reconnaissance(self, target_url: str) -> Dict[str, Any]:
        """Visual reconnaissance with browser automation"""
        
        phase_results = {
            "name": "Visual Reconnaissance", 
            "tests": [],
            "findings": []
        }
        
        print("  üì° Loading target website in browser...")
        
        try:
            # Navigate to target
            browser_result = await self.browser_automator.test_url(target_url)
            
            if browser_result.success:
                print(f"  ‚úÖ Successfully loaded {target_url}")
                print(f"  üìã Page title: {browser_result.page_title}")
                
                # Wait for user to see the page
                await asyncio.sleep(3)
                
                # Test common directories visually
                print("  üîç Testing common directories...")
                common_dirs = ["/admin", "/login", "/wp-admin", "/phpmyadmin", "/uploads"]
                
                for directory in common_dirs:
                    test_url = urljoin(target_url, directory)
                    print(f"    üîó Testing: {test_url}")
                    
                    try:
                        self.browser_automator.driver.get(test_url)
                        await asyncio.sleep(2)
                        
                        page_source = self.browser_automator.driver.page_source
                        
                        if "404" not in page_source and "Not Found" not in page_source:
                            print(f"    ‚úÖ Found accessible directory: {test_url}")
                            phase_results["findings"].append({
                                "type": "accessible_directory",
                                "url": test_url,
                                "severity": "info"
                            })
                        else:
                            print(f"    ‚ùå Directory not found: {test_url}")
                            
                    except Exception as e:
                        print(f"    ‚ö†Ô∏è  Error testing {test_url}: {e}")
                
                # Return to main page
                self.browser_automator.driver.get(target_url)
                
            else:
                print(f"  ‚ùå Failed to load {target_url}")
                
        except Exception as e:
            print(f"  ‚ùå Reconnaissance failed: {e}")
        
        return phase_results

    async def _visual_vulnerability_testing(self, target_url: str) -> Dict[str, Any]:
        """Visual vulnerability testing with browser interaction"""
        
        phase_results = {
            "name": "Visual Vulnerability Testing",
            "tests": [],
            "findings": []
        }
        
        print("  üï∑Ô∏è  Looking for forms and input fields...")
        
        try:
            # Navigate to target
            await self.browser_automator.driver.get(target_url)
            await asyncio.sleep(2)
            # Find all forms and inputs
            forms = self.browser_automator.driver.find_elements("tag name", "form")
            inputs = self.browser_automator.driver.find_elements("tag name", "input")
            textareas = self.browser_automator.driver.find_elements("tag name", "textarea")
            
            print(f"  üìù Found {len(forms)} forms, {len(inputs)} inputs, {len(textareas)} textareas")
            
            # Test XSS on input fields
            if inputs or textareas:
                print("  üö® Testing XSS payloads...")
                
                xss_payloads = [
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>"
                ]
                
                for i, payload in enumerate(xss_payloads):
                    print(f"    üéØ Testing XSS payload {i+1}: {payload[:30]}...")
                    
                    if inputs:
                        try:
                            input_field = inputs[0]
                            input_field.clear()
                            input_field.send_keys(payload)
                            
                            # Try to submit
                            submit_buttons = self.browser_automator.driver.find_elements("css selector", "input[type='submit'], button[type='submit'], button")
                            if submit_buttons:
                                print(f"    üì§ Submitting XSS payload...")
                                submit_buttons[0].click()
                                await asyncio.sleep(3)
                                
                                # Check for alert
                                try:
                                    alert = self.browser_automator.driver.switch_to.alert
                                    if alert:
                                        print(f"    üö® XSS VULNERABILITY CONFIRMED!")
                                        alert.accept()
                                        phase_results["findings"].append({
                                            "type": "xss_vulnerability",
                                            "payload": payload,
                                            "severity": "high"
                                        })
                                except:
                                    print(f"    ‚úÖ No XSS alert detected")
                                
                                await self.browser_automator.driver.get(target_url)
                                await asyncio.sleep(2)
                                
                        except Exception as e:
                            print(f"    ‚ö†Ô∏è  Error testing XSS: {e}")
            
            # Test SQL Injection
            print("  üíâ Testing SQL Injection...")
            
            sql_payloads = ["' OR '1'='1", "admin'--"]
            
            for i, payload in enumerate(sql_payloads):
                print(f"    üéØ Testing SQL payload {i+1}: {payload}")
                
                test_url = f"{target_url}?id={payload}"
                
                try:
                    self.browser_automator.driver.get(test_url)
                    await asyncio.sleep(3)
                    
                    page_source = self.browser_automator.driver.page_source.lower()
                    
                    sql_errors = ["sql syntax", "mysql_fetch", "warning: mysql"]
                    
                    for error in sql_errors:
                        if error in page_source:
                            print(f"    üö® SQL INJECTION VULNERABILITY! Found: {error}")
                            phase_results["findings"].append({
                                "type": "sql_injection",
                                "payload": payload,
                                "error_indicator": error,
                                "severity": "critical"
                            })
                            break
                    else:
                        print(f"    ‚úÖ No SQL errors detected")
                        
                except Exception as e:
                    print(f"    ‚ö†Ô∏è  Error testing SQL injection: {e}")
            
            self.browser_automator.driver.get(target_url)
            
        except Exception as e:
            print(f"  ‚ùå Vulnerability testing failed: {e}")
            
        except Exception as e:
            print(f"  ‚ùå Vulnerability testing failed: {e}")
        
        return phase_results

    async def _visual_exploitation(self, target_url: str, pentest_data: Dict) -> Dict[str, Any]:
        """AI-guided visual exploitation"""
        
        phase_results = {
            "name": "Visual Exploitation",
            "tests": [],
            "findings": []
        }
        
        print("  ü§ñ AI analyzing findings and suggesting advanced tests...")
        
        # Simple advanced tests for demo
        print("  üéØ Executing advanced payload tests...")
        
        try:
            # Advanced SQL injection
            advanced_sql = "1' UNION SELECT user(),version(),database()--"
            test_url = f"{target_url}?id={advanced_sql}"
            print(f"    üíâ Testing advanced SQL: {advanced_sql}")
            
            self.browser_automator.driver.get(test_url)
            await asyncio.sleep(4)
            
            # Advanced XSS
            if self.browser_automator.driver.find_elements("tag name", "input"):
                print("    üö® Testing advanced XSS...")
                inputs = self.browser_automator.driver.find_elements("tag name", "input")
                if inputs:
                    advanced_xss = "<svg onload=alert('Advanced-XSS')>"
                    inputs[0].clear()
                    inputs[0].send_keys(advanced_xss)
                    await asyncio.sleep(3)
            
            phase_results["tests"].append({
                "name": "Advanced Exploitation",
                "status": "completed"
            })
                    
        except Exception as e:
            print(f"  ‚ùå Advanced testing failed: {e}")
        
        return phase_results

    async def autonomous_pentest(self, target_url: str, 
                                depth: int = 3,
                                max_tests: int = 20) -> Dict[str, Any]:
        """
        Perform autonomous penetration testing on a target
        
        Args:
            target_url: Target website URL
            depth: How deep to explore (number of levels)
            max_tests: Maximum number of tests to perform
            
        Returns:
            Comprehensive pentest report
        """
        self.logger.info(f"üéØ Starting autonomous pentest of {target_url}")
        
        pentest_report = {
            "target": target_url,
            "start_time": datetime.now().isoformat(),
            "phases": [],
            "vulnerabilities": [],
            "recommendations": [],
            "risk_score": 0,
            "summary": ""
        }
        
        try:
            # Phase 1: Initial Reconnaissance
            recon_results = await self._phase_reconnaissance(target_url)
            pentest_report["phases"].append(recon_results)
            
            # Phase 2: Automated Vulnerability Scanning
            vuln_results = await self._phase_vulnerability_scanning(target_url, recon_results)
            pentest_report["phases"].append(vuln_results)
            
            # Phase 3: Intelligent Exploitation Attempts
            exploit_results = await self._phase_intelligent_exploitation(target_url, vuln_results)
            pentest_report["phases"].append(exploit_results)
            
            # Phase 4: AI-Driven Analysis and Reporting
            analysis_results = await self._phase_ai_analysis(pentest_report)
            pentest_report.update(analysis_results)
            
            self.logger.info("üéâ Autonomous pentest completed")
            return pentest_report
            
        except Exception as e:
            self.logger.error(f"‚ùå Pentest failed: {e}")
            pentest_report["error"] = str(e)
            return pentest_report
    
    async def _phase_reconnaissance(self, target_url: str) -> Dict[str, Any]:
        """Phase 1: Gather information about the target"""
        
        self.logger.info("üîç Phase 1: Reconnaissance")
        phase_results = {
            "name": "Reconnaissance",
            "tests": [],
            "findings": []
        }
        
        # Basic HTTP request analysis
        test_result = await self._test_basic_http_info(target_url)
        phase_results["tests"].append(test_result)
        
        # Browser-based reconnaissance
        browser_result = await self.browser_automator.test_url(target_url)
        if browser_result.success:
            # Extract links, forms, and interesting elements
            content = await self.browser_automator.extract_page_content(target_url)
            phase_results["tests"].append({
                "name": "Browser Content Analysis",
                "result": content,
                "status": "completed"
            })
        
        # Directory enumeration with common paths
        common_dirs = [
            "/admin", "/login", "/wp-admin", "/phpmyadmin", 
            "/uploads", "/backup", "/config", "/test",
            "/db", "/database", "/sql", "/api"
        ]
        
        for directory in common_dirs[:5]:  # Test first 5
            test_url = urljoin(target_url, directory)
            dir_result = await self._test_directory_access(test_url)
            if dir_result["accessible"]:
                phase_results["findings"].append({
                    "type": "accessible_directory",
                    "url": test_url,
                    "severity": "info"
                })
        
        return phase_results
    
    async def _phase_vulnerability_scanning(self, target_url: str, recon_data: Dict) -> Dict[str, Any]:
        """Phase 2: Scan for common vulnerabilities"""
        
        self.logger.info("üîé Phase 2: Vulnerability Scanning")
        phase_results = {
            "name": "Vulnerability Scanning",
            "tests": [],
            "findings": []
        }
        
        # SQL Injection testing
        sql_results = await self._test_sql_injection(target_url)
        phase_results["tests"].append(sql_results)
        
        # XSS testing
        xss_results = await self._test_xss_vulnerabilities(target_url)
        phase_results["tests"].append(xss_results)
        
        # Security headers analysis
        headers_result = await self._test_security_headers(target_url)
        phase_results["tests"].append(headers_result)
        
        # SSL/TLS testing
        ssl_result = await self._test_ssl_configuration(target_url)
        phase_results["tests"].append(ssl_result)
        
        return phase_results
    
    async def _phase_intelligent_exploitation(self, target_url: str, vuln_data: Dict) -> Dict[str, Any]:
        """Phase 3: AI-guided exploitation attempts"""
        
        self.logger.info("üéØ Phase 3: Intelligent Exploitation")
        phase_results = {
            "name": "Intelligent Exploitation",
            "tests": [],
            "findings": []
        }
        
        # Ask AI what to test based on findings so far
        ai_prompt = f"""
        Based on the reconnaissance and vulnerability scan results for {target_url}, 
        what specific penetration testing techniques should I try next?
        
        Previous findings: {json.dumps(vuln_data, indent=2)[:1000]}
        
        Suggest 3-5 specific commands or techniques to test, focusing on the most promising attack vectors.
        Format as JSON: {{"suggested_tests": ["test1", "test2", ...]}}
        """
        
        try:
            ai_suggestions = await self.ai_analyzer.analyze_text_prompt(ai_prompt)
            if ai_suggestions.analysis:
                # Parse AI suggestions and execute them
                suggested_tests = self._parse_ai_suggestions(ai_suggestions.analysis)
                for test in suggested_tests[:3]:  # Execute top 3 suggestions
                    test_result = await self._execute_ai_suggested_test(target_url, test)
                    phase_results["tests"].append(test_result)
        except Exception as e:
            self.logger.warning(f"AI suggestions failed: {e}")
        
        return phase_results
    
    async def _phase_ai_analysis(self, pentest_report: Dict) -> Dict[str, Any]:
        """Phase 4: AI-driven final analysis and reporting"""
        
        self.logger.info("ü§ñ Phase 4: AI Analysis & Reporting")
        
        # Comprehensive AI analysis of all findings
        analysis_prompt = f"""
        Analyze this penetration testing report and provide:
        1. Overall risk assessment (Low/Medium/High/Critical)
        2. Top 3 most critical vulnerabilities found
        3. Prioritized remediation recommendations
        4. Executive summary
        
        Pentest Report: {json.dumps(pentest_report, indent=2)[:2000]}
        
        Respond in JSON format with: risk_score (1-10), vulnerabilities, recommendations, summary
        """
        
        try:
            ai_analysis = await self.ai_analyzer.analyze_text_prompt(analysis_prompt)
            
            # Parse AI analysis
            analysis_data = self._parse_ai_analysis(ai_analysis.analysis)
            return {
                "ai_analysis": analysis_data,
                "risk_score": analysis_data.get("risk_score", 5),
                "summary": analysis_data.get("summary", "AI analysis completed"),
                "recommendations": analysis_data.get("recommendations", [])
            }
            
        except Exception as e:
            self.logger.error(f"AI analysis failed: {e}")
            return {
                "ai_analysis": {"error": str(e)},
                "risk_score": 0,
                "summary": "AI analysis unavailable",
                "recommendations": ["Manual review recommended"]
            }
    
    async def _test_basic_http_info(self, url: str) -> Dict[str, Any]:
        """Test basic HTTP information"""
        
        try:
            result = await self.terminal_executor.execute_api_request(url, "GET")
            return {
                "name": "Basic HTTP Analysis",
                "status": "completed",
                "response_code": result.return_code,
                "headers": result.metadata.get("headers", {}) if result.metadata else {},
                "server_info": result.metadata.get("headers", {}).get("server", "Unknown") if result.metadata else "Unknown"
            }
        except Exception as e:
            return {
                "name": "Basic HTTP Analysis",
                "status": "failed",
                "error": str(e)
            }
    
    async def _test_directory_access(self, url: str) -> Dict[str, Any]:
        """Test if a directory is accessible"""
        
        try:
            result = await self.terminal_executor.execute_api_request(url, "GET")
            return {
                "accessible": result.success and result.return_code != 404,
                "status_code": result.return_code,
                "url": url
            }
        except:
            return {"accessible": False, "status_code": 0, "url": url}
    
    async def _test_sql_injection(self, url: str) -> Dict[str, Any]:
        """Test for SQL injection vulnerabilities"""
        
        test_result = {
            "name": "SQL Injection Testing",
            "vulnerabilities_found": [],
            "tests_performed": 0
        }
        
        # Test common SQL injection payloads
        for payload in self.test_payloads["sql_injection"][:3]:
            test_url = f"{url}?id={payload}"
            try:
                result = await self.terminal_executor.execute_api_request(test_url, "GET")
                test_result["tests_performed"] += 1
                
                # Look for SQL error indicators
                if any(error in result.stdout.lower() for error in 
                      ["sql", "mysql", "oracle", "postgres", "sqlite", "syntax error"]):
                    test_result["vulnerabilities_found"].append({
                        "type": "sql_injection",
                        "payload": payload,
                        "evidence": result.stdout[:200]
                    })
            except:
                continue
        
        return test_result
    
    async def _test_xss_vulnerabilities(self, url: str) -> Dict[str, Any]:
        """Test for XSS vulnerabilities"""
        
        test_result = {
            "name": "XSS Vulnerability Testing",
            "vulnerabilities_found": [],
            "tests_performed": 0
        }
        
        # Test XSS payloads
        for payload in self.test_payloads["xss"][:3]:
            test_url = f"{url}?search={payload}"
            try:
                result = await self.terminal_executor.execute_api_request(test_url, "GET")
                test_result["tests_performed"] += 1
                
                # Check if payload is reflected
                if payload in result.stdout:
                    test_result["vulnerabilities_found"].append({
                        "type": "reflected_xss",
                        "payload": payload,
                        "location": "search parameter"
                    })
            except:
                continue
        
        return test_result
    
    async def _test_security_headers(self, url: str) -> Dict[str, Any]:
        """Test security headers configuration"""
        
        try:
            result = await self.terminal_executor.execute_api_request(url, "GET")
            headers = result.metadata.get("headers", {}) if result.metadata else {}
            
            security_headers = {
                "X-Frame-Options": headers.get("x-frame-options"),
                "X-Content-Type-Options": headers.get("x-content-type-options"),
                "X-XSS-Protection": headers.get("x-xss-protection"),
                "Strict-Transport-Security": headers.get("strict-transport-security"),
                "Content-Security-Policy": headers.get("content-security-policy")
            }
            
            missing_headers = [h for h, v in security_headers.items() if not v]
            
            return {
                "name": "Security Headers Analysis",
                "headers_present": {k: v for k, v in security_headers.items() if v},
                "missing_headers": missing_headers,
                "security_score": max(0, 100 - (len(missing_headers) * 20))
            }
        except Exception as e:
            return {
                "name": "Security Headers Analysis",
                "error": str(e),
                "security_score": 0
            }
    
    async def _test_ssl_configuration(self, url: str) -> Dict[str, Any]:
        """Test SSL/TLS configuration"""
        
        if not url.startswith("https://"):
            return {
                "name": "SSL/TLS Testing",
                "status": "skipped",
                "reason": "Not HTTPS"
            }
        
        # Basic SSL test using curl equivalent
        try:
            # This is a simplified test - in real implementation you'd use more sophisticated SSL testing
            result = await self.terminal_executor.execute_api_request(url, "GET")
            return {
                "name": "SSL/TLS Testing",
                "status": "completed",
                "https_enabled": url.startswith("https://"),
                "connection_successful": result.success
            }
        except Exception as e:
            return {
                "name": "SSL/TLS Testing",
                "status": "failed",
                "error": str(e)
            }
    
    def _parse_ai_suggestions(self, ai_response: str) -> List[str]:
        """Parse AI suggestions from response"""
        try:
            # Try to extract JSON
            if "{" in ai_response:
                json_part = ai_response[ai_response.find("{"):ai_response.rfind("}")+1]
                data = json.loads(json_part)
                return data.get("suggested_tests", [])
        except:
            pass
        
        # Fallback: extract suggestions from text
        suggestions = []
        lines = ai_response.split('\n')
        for line in lines:
            if any(keyword in line.lower() for keyword in ["test", "try", "check", "scan"]):
                suggestions.append(line.strip())
        
        return suggestions[:5]  # Max 5 suggestions
    
    def _parse_ai_analysis(self, ai_response: str) -> Dict[str, Any]:
        """Parse AI analysis from response"""
        try:
            if "{" in ai_response:
                json_part = ai_response[ai_response.find("{"):ai_response.rfind("}")+1]
                return json.loads(json_part)
        except:
            pass
        
        # Fallback analysis
        return {
            "risk_score": 5,
            "summary": ai_response[:500],
            "recommendations": ["Manual security review recommended"],
            "vulnerabilities": []
        }
    
    async def _execute_ai_suggested_test(self, target_url: str, test_description: str) -> Dict[str, Any]:
        """Execute a test suggested by AI"""
        
        self.logger.info(f"üéØ Executing AI-suggested test: {test_description}")
        
        try:
            # Convert AI suggestion to actual command
            if "sql" in test_description.lower():
                return await self._test_sql_injection(target_url)
            elif "xss" in test_description.lower():
                return await self._test_xss_vulnerabilities(target_url)
            elif "directory" in test_description.lower():
                return await self._test_directory_access(target_url + "/admin")
            else:
                # Generic test
                result = await self.terminal_executor.execute_api_request(target_url, "GET")
                return {
                    "name": f"AI Suggested: {test_description}",
                    "status": "completed",
                    "result": result.success
                }
        except Exception as e:
            return {
                "name": f"AI Suggested: {test_description}",
                "status": "failed",
                "error": str(e)
            }
